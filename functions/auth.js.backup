const functions = require("firebase-functions");
const admin = require("firebase-admin");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

/**
 * Login with email and password
 */
exports.loginWithEmail = functions.https.onCall(async (data, context) => {
  const {email, password} = data;

  if (!email || !password) {
    throw new functions.https.HttpsError(
        "invalid-argument",
        "Email and password are required",
    );
  }

  try {
    // Verify credentials using Firebase Auth REST API
    const authUrl = `https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=${process.env.FIREBASE_API_KEY}`;
    const authResponse = await fetch(authUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        email: email,
        password: password,
        returnSecureToken: true,
      }),
    });

    const authData = await authResponse.json();

    if (!authResponse.ok) {
      const errorMessage = (authData.error && authData.error.message) ||
          "Authentication failed";
      throw new Error(errorMessage);
    }

    // Get user record from Admin SDK
    const userRecord = await admin.auth().getUserByEmail(email);

    // For security, we'll create a custom token instead of using client auth
    const customToken = await admin.auth().createCustomToken(userRecord.uid);

    // Get user role from custom claims, default to 'customer'
    const userRole = (userRecord.customClaims &&
        userRecord.customClaims.role) || "customer";

    return {
      success: true,
      user: {
        uid: userRecord.uid,
        email: userRecord.email,
        displayName: userRecord.displayName,
        photoURL: userRecord.photoURL,
        role: userRole,
      },
      customToken,
    };
  } catch (error) {
    console.error("Email login error:", error);
    throw new functions.https.HttpsError(
        "unauthenticated",
        "Invalid email or password",
    );
  }
});

/**
 * Register with email and password
 */
exports.registerWithEmail = functions.https.onCall(async (data, context) => {
  const {email, password, displayName} = data;

  if (!email || !password || !displayName) {
    throw new functions.https.HttpsError(
        "invalid-argument",
        "Email, password, and display name are required",
    );
  }

  try {
    // Create user with Admin SDK
    const userRecord = await admin.auth().createUser({
      email: email,
      password: password,
      displayName: displayName,
      emailVerified: false,
    });

    // Set default role as customer
    await admin.auth().setCustomUserClaims(userRecord.uid, {
      role: "customer",
    });

    // Create custom token for the client
    const customToken = await admin.auth().createCustomToken(userRecord.uid);

    return {
      success: true,
      user: {
        uid: userRecord.uid,
        email: userRecord.email,
        displayName: displayName,
        photoURL: userRecord.photoURL,
        role: "customer",
      },
      customToken,
    };
  } catch (error) {
    console.error("Email registration error:", error);
    throw new functions.https.HttpsError(
        "internal",
        "Registration failed",
    );
  }
});

/**
 * Login with Google OAuth
 */
exports.loginWithGoogle = functions.https.onCall(async (data, context) => {
  const {idToken} = data;

  if (!idToken) {
    throw new functions.https.HttpsError(
        "invalid-argument",
        "Google ID token is required",
    );
  }

  try {
    // Verify the Google token
    const decodedToken = await admin.auth().verifyIdToken(idToken);

    // Create or get user
    let userRecord;
    let isNewUser = false;
    try {
      userRecord = await admin.auth().getUser(decodedToken.uid);
    } catch (error) {
      // User doesn't exist, create them
      userRecord = await admin.auth().createUser({
        uid: decodedToken.uid,
        email: decodedToken.email,
        displayName: decodedToken.name,
        photoURL: decodedToken.picture,
        emailVerified: decodedToken.email_verified,
      });
      isNewUser = true;
    }

    // Set default role for new users
    if (isNewUser) {
      await admin.auth().setCustomUserClaims(userRecord.uid, {
        role: "customer",
      });
    }

    // Create custom token for the client
    const customToken = await admin.auth().createCustomToken(userRecord.uid);

    // Get user role from custom claims, default to 'customer'
    const userRole = (userRecord.customClaims &&
        userRecord.customClaims.role) || "customer";

    return {
      success: true,
      user: {
        uid: userRecord.uid,
        email: userRecord.email,
        displayName: userRecord.displayName,
        photoURL: userRecord.photoURL,
        role: userRole,
      },
      customToken,
    };
  } catch (error) {
    console.error("Google login error:", error);
    throw new functions.https.HttpsError(
        "unauthenticated",
        "Google authentication failed",
    );
  }
});

/**
 * Login with Facebook OAuth
 */
exports.loginWithFacebook = functions.https.onCall(async (data, context) => {
  const {accessToken} = data;

  if (!accessToken) {
    throw new functions.https.HttpsError(
        "invalid-argument",
        "Facebook access token is required",
    );
  }

  try {
    // Verify Facebook token by making a request to Facebook's API
    const response = await fetch(`https://graph.facebook.com/me?access_token=${accessToken}&fields=id,name,email,picture`);
    const facebookUser = await response.json();

    if (!facebookUser.id) {
      throw new Error("Invalid Facebook token");
    }

    // Create or get user
    let userRecord;
    let isNewUser = false;
    try {
      // Try to find user by email
      userRecord = await admin.auth().getUserByEmail(facebookUser.email);
    } catch (error) {
      // User doesn't exist, create them
      userRecord = await admin.auth().createUser({
        email: facebookUser.email,
        displayName: facebookUser.name,
        photoURL: facebookUser.picture && facebookUser.picture.data ?
            facebookUser.picture.data.url : null,
        emailVerified: true,
      });
      isNewUser = true;
    }

    // Set default role for new users
    if (isNewUser) {
      await admin.auth().setCustomUserClaims(userRecord.uid, {
        role: "customer",
      });
    }

    // Create custom token for the client
    const customToken = await admin.auth().createCustomToken(userRecord.uid);

    // Get user role from custom claims, default to 'customer'
    const userRole = (userRecord.customClaims &&
        userRecord.customClaims.role) || "customer";

    return {
      success: true,
      user: {
        uid: userRecord.uid,
        email: userRecord.email,
        displayName: userRecord.displayName,
        photoURL: userRecord.photoURL,
        role: userRole,
      },
      customToken,
    };
  } catch (error) {
    console.error("Facebook login error:", error);
    throw new functions.https.HttpsError(
        "unauthenticated",
        "Facebook authentication failed",
    );
  }
});

/**
 * Get current user info
 */
exports.getCurrentUser = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    return {user: null};
  }

  try {
    const userRecord = await admin.auth().getUser(context.auth.uid);

    // Get user role from custom claims, default to 'customer'
    const userRole = (userRecord.customClaims &&
        userRecord.customClaims.role) || "customer";

    return {
      user: {
        uid: userRecord.uid,
        email: userRecord.email,
        displayName: userRecord.displayName,
        photoURL: userRecord.photoURL,
        role: userRole,
      },
    };
  } catch (error) {
    console.error("Get current user error:", error);
    return {user: null};
  }
});

/**
 * Logout user
 */
exports.logout = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError(
        "unauthenticated",
        "User must be authenticated",
    );
  }

  try {
    // Revoke all refresh tokens for the user
    await admin.auth().revokeRefreshTokens(context.auth.uid);

    return {success: true};
  } catch (error) {
    console.error("Logout error:", error);
    throw new functions.https.HttpsError(
        "internal",
        "Logout failed",
    );
  }
});

/**
 * Refresh user token
 */
exports.refreshToken = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError(
        "unauthenticated",
        "User must be authenticated",
    );
  }

  try {
    // Create a new custom token
    const customToken = await admin.auth().createCustomToken(context.auth.uid);

    return {
      success: true,
      customToken,
    };
  } catch (error) {
    console.error("Token refresh error:", error);
    throw new functions.https.HttpsError(
        "internal",
        "Token refresh failed",
    );
  }
});

/**
 * Set user role (admin only)
 */
exports.setUserRole = functions.https.onCall(async (data, context) => {
  // Check if user is authenticated
  if (!context.auth) {
    throw new functions.https.HttpsError(
        "unauthenticated",
        "User must be authenticated",
    );
  }

  const {uid, role} = data;

  if (!uid || !role) {
    throw new functions.https.HttpsError(
        "invalid-argument",
        "User ID and role are required",
    );
  }

  // Valid roles
  const validRoles = ["customer", "admin"];
  if (!validRoles.includes(role)) {
    throw new functions.https.HttpsError(
        "invalid-argument",
        "Invalid role. Must be 'customer' or 'admin'",
    );
  }

  try {
    // Check if current user is admin
    const currentUserRecord = await admin.auth().getUser(context.auth.uid);
    const currentUserRole = (currentUserRecord.customClaims &&
        currentUserRecord.customClaims.role) || "customer";

    if (currentUserRole !== "admin") {
      throw new functions.https.HttpsError(
          "permission-denied",
          "Only admins can set user roles",
      );
    }

    // Set the custom claims for the target user
    await admin.auth().setCustomUserClaims(uid, {role: role});

    return {
      success: true,
      message: `User role updated to ${role}`,
    };
  } catch (error) {
    console.error("Set user role error:", error);
    throw new functions.https.HttpsError(
        "internal",
        "Failed to set user role",
    );
  }
});

// Admin authentication functions
const ADMIN_JWT_SECRET =
    "your-super-secure-jwt-secret-change-this-in-production";

/**
 * Admin login function - DEPRECATED
 * Use HTTP endpoint /api/admin/login instead
 * The callable function has been removed to prevent CORS issues.
 * All admin authentication now goes through HTTP endpoints.
 */

/**
 * Admin logout function - MOVED TO HTTP ENDPOINT
 */
// exports.adminLogout = functions.https.onCall(async (data, context) => {
  // For JWT tokens, logout is handled client-side by removing the token
  // You could implement a token blacklist here if needed
  return {
    success: true,
    message: "Logged out successfully",
  };
});

/**
 * Verify admin token
 */
exports.verifyAdminToken = functions.https.onCall(async (data, context) => {
  console.log("verifyAdminToken called with data:", {
    data: data,
    dataType: typeof data,
    dataKeys: data ? Object.keys(data) : "no data",
  });

  // Handle the case where data is wrapped in another data object
  let tokenData = data;
  if (data && data.data && typeof data.data === "object") {
    console.log("Token data is wrapped, extracting inner data object");
    tokenData = data.data;
  }

  const {token} = tokenData || {};

  if (!token) {
    console.log("Missing token:", {hasToken: !!token});
    throw new functions.https.HttpsError(
        "invalid-argument",
        "Token is required",
    );
  }

  try {
    const decoded = jwt.verify(token, ADMIN_JWT_SECRET);
    const db = admin.firestore();

    // Verify admin still exists and is active
    const adminDoc = await db.collection("admins").doc(decoded.adminId).get();

    if (!adminDoc.exists || !adminDoc.data().active) {
      throw new functions.https.HttpsError(
          "unauthenticated",
          "Invalid or inactive admin account",
      );
    }

    const adminData = adminDoc.data();

    return {
      valid: true,
      admin: {
        id: adminDoc.id,
        username: adminData.username,
        email: adminData.email,
        role: adminData.role,
        permissions: adminData.permissions,
        lastLogin: adminData.lastLogin,
      },
    };
  } catch (error) {
    console.error("Token verification error:", error);
    return {
      valid: false,
      message: "Invalid token",
    };
  }
});

/**
 * Create initial admin user (can only be called once during setup)
 */
exports.createInitialAdmin = functions.https.onCall(async (data, context) => {
  const {username, email, password, setupKey} = data;

  console.log("Received data:", {
    username,
    email,
    password: password ? "[REDACTED]" : "undefined",
    setupKey,
  });

  // Validate required fields
  if (!username || !email || !password || !setupKey) {
    console.error("Missing required fields:", {
      username: !!username,
      email: !!email,
      password: !!password,
      setupKey: !!setupKey,
    });
    throw new functions.https.HttpsError(
        "invalid-argument",
        "Username, email, password, and setup key are required",
    );
  }

  // This should only be callable during initial setup
  // In production, you'd want a secure setup key
  if (setupKey !== process.env.ADMIN_SETUP_KEY) {
    console.error("Invalid setup key provided");
    throw new functions.https.HttpsError(
        "permission-denied",
        "Invalid setup key",
    );
  }

  try {
    const db = admin.firestore();

    // Check if any admin already exists
    const existingAdmins = await db.collection("admins").limit(1).get();
    if (!existingAdmins.empty) {
      throw new functions.https.HttpsError(
          "already-exists",
          "Admin users already exist",
      );
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 12);

    // Create admin user
    const adminData = {
      username,
      email,
      hashedPassword,
      role: "super_admin",
      permissions: [
        "manage_products",
        "manage_orders",
        "manage_users",
        "manage_content",
        "manage_settings",
        "view_analytics",
        "manage_admins",
      ],
      active: true,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      lastLogin: null,
    };

    const adminDoc = await db.collection("admins").add(adminData);

    return {
      success: true,
      adminId: adminDoc.id,
      message: "Initial admin user created successfully",
    };
  } catch (error) {
    console.error("Create initial admin error:", error);
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    throw new functions.https.HttpsError(
        "internal",
        "Failed to create admin user",
    );
  }
});
