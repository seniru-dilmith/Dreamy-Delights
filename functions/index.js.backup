const functions = require("firebase-functions");
const admin = require("firebase-admin");

// Import middleware
const {
  requireAdmin,
  setCorsHeaders,
  requireAdminCallable,
} = require("./middleware/auth");

admin.initializeApp();
const db = admin.firestore();

// PUBLIC ENDPOINTS (No authentication required)

// Get featured products - accessible to everyone
exports.getFeaturedProducts = functions.https.onRequest(async (req, res) => {
  setCorsHeaders(res);

  if (req.method === "OPTIONS") {
    res.status(200).send();
    return;
  }

  try {
    const snapshot = await db.collection("featured_products").get();
    const products = [];

    snapshot.forEach((doc) => {
      products.push({
        id: doc.id,
        ...doc.data(),
      });
    });

    res.json({
      success: true,
      data: products,
      count: products.length,
    });
  } catch (error) {
    console.error("Error fetching featured products:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch products",
    });
  }
});

// Get all products with pagination - public access
exports.getProducts = functions.https.onRequest(async (req, res) => {
  setCorsHeaders(res);

  if (req.method === "OPTIONS") {
    res.status(200).send();
    return;
  }

  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const category = req.query.category;

    let query = db.collection("products");

    if (category) {
      query = query.where("category", "==", category);
    }

    const snapshot = await query.limit(limit).get();
    const products = [];

    snapshot.forEach((doc) => {
      products.push({
        id: doc.id,
        ...doc.data(),
      });
    });

    res.json({
      success: true,
      data: products,
      pagination: {
        page,
        limit,
        count: products.length,
      },
    });
  } catch (error) {
    console.error("Error fetching products:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch products",
    });
  }
});

// LOGGED-IN USER ENDPOINTS

// Get user orders - requires authentication
exports.getUserOrders = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError(
        "unauthenticated",
        "User must be authenticated",
    );
  }

  try {
    const userId = context.auth.uid;
    const snapshot = await db.collection("orders")
        .where("userId", "==", userId)
        .orderBy("createdAt", "desc")
        .get();

    const orders = [];
    snapshot.forEach((doc) => {
      orders.push({
        id: doc.id,
        ...doc.data(),
      });
    });

    return {
      success: true,
      data: orders,
    };
  } catch (error) {
    console.error("Error fetching user orders:", error);
    throw new functions.https.HttpsError("internal", "Failed to fetch orders");
  }
});

// Create order - requires authentication
exports.createOrder = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError(
        "unauthenticated",
        "User must be authenticated",
    );
  }

  try {
    const userId = context.auth.uid;
    const {items, totalAmount, shippingAddress} = data;

    // Validate required fields
    if (!items || !Array.isArray(items) || items.length === 0) {
      throw new functions.https.HttpsError(
          "invalid-argument",
          "Order items are required",
      );
    }

    const orderData = {
      userId,
      items,
      totalAmount,
      shippingAddress,
      status: "pending",
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    };

    const docRef = await db.collection("orders").add(orderData);

    return {
      success: true,
      orderId: docRef.id,
      message: "Order created successfully",
    };
  } catch (error) {
    console.error("Error creating order:", error);
    throw new functions.https.HttpsError("internal", "Failed to create order");
  }
});

// Update user profile - requires authentication
exports.updateUserProfile = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError(
        "unauthenticated",
        "User must be authenticated",
    );
  }

  try {
    const userId = context.auth.uid;
    const {name, email, phone, address} = data;

    const updateData = {
      name,
      email,
      phone,
      address,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    };

    await db.collection("users").doc(userId).set(updateData, {merge: true});

    return {
      success: true,
      message: "Profile updated successfully",
    };
  } catch (error) {
    console.error("Error updating profile:", error);
    throw new functions.https.HttpsError(
        "internal",
        "Failed to update profile",
    );
  }
});

// ADMIN ENDPOINTS

// Get all orders - admin only
exports.getAllOrders = functions.https.onRequest(async (req, res) => {
  setCorsHeaders(res);

  if (req.method === "OPTIONS") {
    res.status(200).send();
    return;
  }

  try {
    await requireAdmin(req);

    const snapshot = await db.collection("orders")
        .orderBy("createdAt", "desc")
        .get();

    const orders = [];
    snapshot.forEach((doc) => {
      orders.push({
        id: doc.id,
        ...doc.data(),
      });
    });

    res.json({
      success: true,
      data: orders,
      count: orders.length,
    });
  } catch (error) {
    console.error("Error fetching all orders:", error);
    const statusCode = error.code === "permission-denied" ? 403 : 500;
    res.status(statusCode).json({
      success: false,
      error: error.message,
    });
  }
});

// Add/Update product - admin only
exports.manageProduct = functions.https.onRequest(async (req, res) => {
  setCorsHeaders(res);

  if (req.method === "OPTIONS") {
    res.status(200).send();
    return;
  }

  try {
    await requireAdmin(req);

    const {name, price, description, category, image, featured} = req.body;

    if (req.method === "POST") {
      // Add new product
      const productData = {
        name,
        price: parseFloat(price),
        description,
        category,
        image,
        featured: featured || false,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      };

      const docRef = await db.collection("products").add(productData);

      // Also add to featured_products if featured is true
      if (featured) {
        await db.collection("featured_products").doc(docRef.id)
            .set(productData);
      }

      res.json({
        success: true,
        productId: docRef.id,
        message: "Product added successfully",
      });
    } else if (req.method === "PUT") {
      // Update existing product
      const productId = req.query.id;
      if (!productId) {
        return res.status(400).json({
          success: false,
          error: "Product ID is required for updates",
        });
      }

      const updateData = {
        name,
        price: parseFloat(price),
        description,
        category,
        image,
        featured: featured || false,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      };

      await db.collection("products").doc(productId).update(updateData);

      // Update featured_products collection
      if (featured) {
        await db.collection("featured_products").doc(productId)
            .set(updateData, {merge: true});
      } else {
        await db.collection("featured_products").doc(productId).delete();
      }

      res.json({
        success: true,
        message: "Product updated successfully",
      });
    } else if (req.method === "DELETE") {
      // Delete product
      const productId = req.query.id;
      if (!productId) {
        return res.status(400).json({
          success: false,
          error: "Product ID is required for deletion",
        });
      }

      await db.collection("products").doc(productId).delete();
      await db.collection("featured_products").doc(productId).delete();

      res.json({
        success: true,
        message: "Product deleted successfully",
      });
    }
  } catch (error) {
    console.error("Error managing product:", error);
    const statusCode = error.code === "permission-denied" ? 403 : 500;
    res.status(statusCode).json({
      success: false,
      error: error.message,
    });
  }
});

// Update order status - admin only
exports.updateOrderStatus = functions.https.onCall(async (data, context) => {
  try {
    // Use middleware for admin verification
    await requireAdminCallable(context);

    const {orderId, status} = data;

    if (!orderId || !status) {
      throw new functions.https.HttpsError(
          "invalid-argument",
          "Order ID and status are required",
      );
    }

    await db.collection("orders").doc(orderId).update({
      status,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    });

    return {
      success: true,
      message: "Order status updated successfully",
    };
  } catch (error) {
    console.error("Error updating order status:", error);
    throw new functions.https.HttpsError(
        "internal",
        "Failed to update order status",
    );
  }
});

// Get server time (existing function)
exports.getServerTime = functions.https.onRequest((req, res) => {
  setCorsHeaders(res);
  res.json({serverTime: new Date().toISOString()});
});
